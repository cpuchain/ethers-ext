globalThis.process?.browser||(globalThis.process={browser:!0,env:{}}),function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var r=t();for(var a in r)("object"==typeof exports?exports:e)[a]=r[a]}}(self,(()=>(()=>{"use strict";var e={d:(t,r)=>{for(var a in r)e.o(r,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:r[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{IndexedDB:()=>r});class r{name;version;options;db;constructor({name:e,version:t=1,stores:r=[]}){this.name=e,this.version=t,-1===r.findIndex((({name:e})=>"keyStore"===e))&&r.push({name:"keyStore"}),this.options={upgrade(e){Object.values(e.objectStoreNames).forEach((t=>{e.deleteObjectStore(t)})),r.forEach((({name:t,keyPath:r,indexes:a})=>{const o=e.createObjectStore(t,{keyPath:r,autoIncrement:!0});Array.isArray(a)&&a.forEach((({name:e,unique:t=!1})=>{o.createIndex(e,e,{unique:t})}))}))}},this.db=this.openDB()}async openDB(){try{if(!window?.idb)return void console.log("IDB library is not available!");const e=await window.idb.openDB(this.name,this.version,this.options);return e.addEventListener("onupgradeneeded",(async()=>{await this.deleteDB()})),e}catch(e){if(e.message.includes("A mutation operation was attempted on a database that did not allow mutations."))return void console.log("The browser does not support IndexedDB");if(e.message.includes("less than the existing version"))return console.log(`Upgrading DB ${this.name} to ${this.version}`),void await this.deleteDB();console.log(`openDB error: ${e.message}`)}}async deleteDB(){await(window?.idb?.deleteDB(this.name)),this.db=this.openDB(),await this.db}async getItem({storeName:e,key:t}){try{const r=await this.db;if(!r)return;const a=r.transaction(e).objectStore(e);return await a.get(t)}catch(e){throw new Error(`getItem error: ${e.message}`)}}async addItem({storeName:e,key:t,data:r}){try{const a=await this.db;if(!a)return;const o=a.transaction(e,"readwrite");await o.objectStore(e).get(t)||await o.objectStore(e).add(r)}catch(e){throw new Error(`addItem error: ${e.message}`)}}async putItem({storeName:e,key:t="",data:r}){try{const a=await this.db;if(!a)return;const o=a.transaction(e,"readwrite");await o.objectStore(e).put(r,t)}catch(e){throw new Error(`putItem error: ${e.message}`)}}async deleteItem({storeName:e,key:t}){try{const r=await this.db;if(!r)return;const a=r.transaction(e,"readwrite");await a.objectStore(e).delete(t)}catch(e){throw new Error(`putItem error: ${e.message}`)}}async getAll({storeName:e}){try{const t=await this.db;if(!t)return[];const r=t.transaction(e,"readonly");return await r.objectStore(e).getAll()}catch(e){throw new Error(`getAll error: ${e.message}`)}}async clearStore({storeName:e}){try{const t=await this.db;if(!t)return;const r=t.transaction(e,"readwrite");await r.objectStore(e).clear()}catch(e){throw new Error(`clearStore error: ${e.message}`)}}async createTransactions({storeName:e,data:t}){try{const r=await this.db;if(!r)return;const a=r.transaction(e,"readwrite");await a.objectStore(e).add(t),await a.done}catch(e){throw new Error(`Method createTransactions has error: ${e.message}`)}}async createMultipleTransactions({storeName:e,data:t,index:r}){try{const a=await this.db;if(!a)return;const o=a.transaction(e,"readwrite");for(const e of t)e&&await o.store.put({...e,...r})}catch(e){throw new Error(`Method createMultipleTransactions has error: ${e.message}`)}}get(e){return this.getItem({storeName:"keyStore",key:e})}set(e,t){return this.putItem({storeName:"keyStore",key:e,data:t})}del(e){return this.deleteItem({storeName:"keyStore",key:e})}}return t})()));